
# Object guidelines

Javascript is not a class-based language, it is a multi-paradigm programming language that supports object-oriented programming (OOP) based on prototypes.  
This gives us several different ways of working with objects.  

In Wolox we choose to use the functional paradigm instead of the object oriented paradigm. This is mainly because functional programming allows to write more compressed and predictable code and it is also easier to test.  
So you should avoid using classes.  
But in case you need to use OOP for some reason, you should follow the following guidelines:

> Start with the simplest implementation and move to more complex implementations only as required:
>
> functions > objects > factory functions > functional mixins > classes
>
> You should always use the simplest possible abstraction to solve the problem youâ€™re working on. Start with a pure function. If you need an object with persistent state, try a factory function. If you need to build more complex objects, try functional mixins.

We will try to generate examples and collect all the pros and cons of the different implementations and why we should choose to follow the previous guideline.

## Functions

The functions must be pure functions:

- Each input combination corresponds to exactly one output.
- They only depend on the input data.
- They do not alter the input data. (Immutability)

They should not produce any side effects, that is, they should not change the status of the program.

Using _declarations_:

``` js
const square = {
  length: 10,
  breadth: 10
};

function getArea(square) {
  return square.length * square.breadth;
}

function printAll(square) {
  console.log(`length: ${square.length}`);
  console.log(`breadth: ${square.breadth}`);
  console.log(`area: ${getArea(square)}`);
}

printAll(square);
```

Using _expressions_:

``` js
const square = {
  length: 10,
  breadth: 10
};

const getArea = function(square) {
  return square.length * square.breadth;
}

const printAll = function(square) {
  console.log(`length: ${square.length}`);
  console.log(`breadth: ${square.breadth}`);
  console.log(`area: ${getArea(square)}`);
}

printAll(square);
```

After ES6 we can write them using the arrow functions:

``` js
const square = {
  length: 10,
  breadth: 10
};

const getArea = square => {
  return square.length * square.breadth;
};

const printAll = square => {
  console.log(`length: ${square.length}`);
  console.log(`breadth: ${square.breadth}`);
  console.log(`area: ${getArea(square)}`);
};

printAll(square);
```

## Objects

In the following two examples we can see that we can define methods within an object.
We may want to do this to encapsulate these functions and make it clear that they belong to the object.

``` js
const square = {
  length: 10,
  breadth: 10,

  getArea: function() {
    return this.length * this.breadth;
  }
};

square.printAll = function() {
  console.log(`length: ${this.length}`);
  console.log(`breadth: ${this.breadth}`);
  console.log(`area: ${this.getArea()}`);
};

square.printAll();
```

Note that one of the methods was defined within the definition of the function and another outside. This is just to show that this can be done.

Using ES6 we can avoid the function keyword and write instead:

``` js
const square = {
  length: 10,
  breadth: 10,

  getArea() {
    return this.length * this.breadth;
  }
};

square.printAll = function() {
  console.log(`length: ${this.length}`);
  console.log(`breadth: ${this.breadth}`);
  console.log(`area: ${this.getArea()}`);
};

square.printAll();
```

## Factory functions

As we cannot modify an already defined function without using dirty tricks (Read more about it in the references section), we can state that it is not possible to add methods to a factory function after it was defined. All methods have to be defined within it. What we can do is add methods to an object generated by a factory function as we saw earlier.

``` js
function Rectangle(length, breadth) {
  return {
    length: length,
    breadth: breadth,
    getArea: function() {
      return this.length * this.breadth;
    }
  };
};

const square = Rectangle(10, 10);

square.printAll = function() {
  console.log(`length: ${this.length}`);
  console.log(`breadth: ${this.breadth}`);
  console.log(`area: ${this.getArea()}`);
};

square.printAll();

```

Using ES6 syntax

``` js
const Rectangle = (length, breadth) => {
  return {
    length: length,
    breadth: breadth,
    getArea() {
      return this.length * this.breadth;
    }
  };
};

const square = Rectangle(10, 10);

square.printAll = function() {
  console.log(`length: ${this.length}`);
  console.log(`breadth: ${this.breadth}`);
  console.log(`area: ${this.getArea()}`);
};

square.printAll();
```

## Functional mixins

Functional mixins are a data structure that provides greater abstraction. They also provide true encapsulation. This is something that even classes cannot provide. Also, they allow us to create new mixins expanding others adding new methods. Kind of like in inheritance.

``` js
const Rectangle = (newlength, newbreadth) => o => {
//  Here we define all the attributes of a mixin
  let length = newlength;
  let breadth = newbreadth;
  const getArea = () => length * breadth;

// And here we specify which of the attributes we want to make public, you can comment them and see that the result of trying to print these attributes will be undefined but the object is able to access them internally.
  return Object.assign({}, o, {
    length,
    breadth,
    getArea
  });
};

// We can also define and specify that an attribute is public at the same time
const printAll = () => o =>
  Object.assign({}, o, {
    printAll: () => {
      console.log(`length: ${o.length}`);
      console.log(`breadth: ${o.breadth}`);
      console.log(`area: ${o.getArea()}`);
    }
  });

const square = Rectangle(11, 11)({});
console.log(square.getArea());

// At this point we have two ways of creating the object, the first one involves defining a pipe function:
const pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);
// OR...
// import pipe from `lodash/fp/flow`;

// The declaration is a more expanded one
const createRectangle = (breadth, length) =>
  pipe(
    Rectangle(breadth, length),
    printAll()
  )({});

// The other way is more compressed but more difficult to read and also does not need the pipe function.
const createRectangle2 = (breadth, length) =>
  printAll()(Rectangle(breadth, length)({}));

const square2 = createRectangle(9, 9);
const square3 = createRectangle2(3, 4);
square2.printAll();
square3.printAll();

// This is how we access the attributes of the object created by the mixin.
console.log('square2.length', square2.length);
console.log('square2.breadth', square2.breadth);
console.log('square3.length', square3.length);
console.log('square3.breadth', square3.breadth);
```

## Classes

There are two main ways of implementing classes in Javascript.

### _Using a constructor function_

Note that in this context, the use of the __function__ keyword cannot be avoided, we cannot use arrow functions because the context is not passed correctly with the keyword __this__.  
Note2: Although it looks similar, it is very different from a factory function.
The use of constructors (or classes) should be avoided as they have many disadvantages (read more about it in the references section). Use factory functions instead.

``` js
function Rectangle(length, breadth) {
  this.length = length;
  this.breadth = breadth;

  this.getArea = function() {
    return this.length * this.breadth;
  };
}

Rectangle.prototype.printAll = function() {
  console.log(`The length is: ${this.length}`);
  console.log(`The breadth is: ${this.breadth}`);
  console.log(`The area is: ${this.getArea()}`);
}

const square = new Rectangle(10, 10);
square.printAll();
```

### _Using the __class__ syntax introduced in ES6_

This is only syntactical sugar of what we did before.

Declaring the method inside the Object:

``` js
class Rectangle {
  constructor(length, breadth) {
    this.length = length;
    this.breadth = breadth;
  }

  getArea() {
    return this.length * this.breadth;
  };
}

Rectangle.prototype.printAll = function() {
  console.log(`The length is: ${this.length}`);
  console.log(`The breadth is: ${this.breadth}`);
  console.log(`The area is: ${this.getArea()}`);
};


const square = new Rectangle(10, 10);
square.printAll();
```

## Resources

[Pros and cons of functional programming](https://itnext.io/pros-and-cons-of-functional-programming-32cdf527e1c2)
[Functional mixins composing software](https://medium.com/javascript-scene/functional-mixins-composing-software-ffb66d5e731c)  
[Functional programming in javascript](https://codeburst.io/functional-programming-in-javascript-e57e7e28c0e5)  
[Can you alter a javascript function after declaring it?](https://stackoverflow.com/questions/2136522/can-you-alter-a-javascript-function-after-declaring-it)

## Useful links

[Javascript factory functions vs constructor functions vs classes](https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor-functions-vs-classes-2f22ceddf33e)  
[Constructor function vs factory functions](https://stackoverflow.com/questions/8698726/constructor-function-vs-factory-functions)
[Composition is harder with classes.](https://medium.com/javascript-scene/why-composition-is-harder-with-classes-c3e627dcd0aa)
